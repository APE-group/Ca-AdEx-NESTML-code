#ca_adex_alt - Two compartment Ca-AdEx neuron NESTML description
################################################################
#
#  Copyright © 2025   Elena Pastorelli          <elena.pastorelli@roma1.infn.it>
#  Copyright © 2025   Pier Stanislao Paolucci   <pier.paolucci@roma1.infn.it>
#  Copyright © 2025   Pooja Babu                <p.babu@fz-juelich.de>
#
#  SPDX-License-Identifier: GPL-3.0-only
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#  Note: Please keep the list of original authors and feel free to
#  add your name if you make substantial contributions, in accordance
#  with the GPL-3 license.
#
#
#
#Description
#+++++++++++
#
#ca_adex_alt is the two compartment spiking neuron that implements the calcium spikes according to Pastorelli et al. (2025)[1].
#This is an alternate modle description of ``ca_adex.nestml``, where the covolutions are replaced by second-order ODEs and correspoding onReceive blocks for the spike events.
#
#Neuronal equations:
#
# Somatic compartment:
#.. math::
#
#   C_m^s \frac{dV^s}{dt} &=
#   -g_L^s(V^s-E_L^s)+g_L^s\Delta_T\exp\left(\frac{V^s-V_{th}^s}{\Delta_T}\right) +
#   - g_e^s(t)(V^s-E_e^s)-g_i^s(t)(V^s-E_i^s) +
#   - g_w w + I_e^s - g_C(V^s-V^d)
#
#Adaptation:
#
#.. math::
#
#    \tau_w \frac{dw}{dt} &= a(V^s-E_L^s) +b\sum_{k}\delta (t-t_{k}) - w
#
#Distal compartment
#
#.. math::
#
#   C_m^d \frac{dV^d}{dt} =
#   -g_L^d(V^d-E_L^d) - g_e^d(t)(V^d-E_e^d)-g_i^d(t)(V^d-E_i^d) +
#   + I_{Ca} + I_{K_{Ca}} + w_{BAP}\sum_{k}\delta (t-(t_{k}+d_{BAP}))+
#   + I_e^d + g_C(V^d-V^s)
#
#Ca concentration:
#
#.. math::
#
#   \frac{d[Ca]}{dt} &= \phi_{Ca}I_{Ca} - \frac{[Ca] - [Ca]_0}{\tau_{Ca}}
#
#
#
#References
#++++++++++
#
#.. [1] Pastorelli E., Yegenoglu A., Kolodziej N., Wybo W., Simula F., Diaz-Pier S.,
#   	Storm J.F., Paolucci P.S. (2025). Simplified two-compartment neuron with calcium dynamics
#       capturing brain-state specific apical-amplification, -isolation and -drive.
#       Front. Comput. Neurosci. DOI: https://doi.org/10.3389/fncom.2025.1566196

model ca_adex_alt:

    state:
        V_m_s mV = e_L_s       # Membrane potential
        w mV = 0 mV            # Spike-adaptation
        refr_t ms = 0 ms       # Refractory period timer
        bap_t ms = 0 ms        # Back propagation timer
        bap_active boolean = false

        V_m_d mV = e_L_d
        c_Ca mmol = Ca_0
        m_Ca real = m_inf_Ca(e_L_d)
        h_Ca real = h_inf_Ca(e_L_d)

        m_K real = m_inf_K(Ca_0)

        # Soma
        g_exc nS = 0 nS
        g_exc' nS/ms = 0 nS/ms
        g_inh nS = 0 nS
        g_inh' nS/ms = 0 nS/ms

        ##### Distal #####
        g_excD nS = 0 nS
        g_excD' nS/ms = 0 nS/ms
        g_inhD nS = 0 nS
        g_inhD' nS/ms = 0 nS/ms

        # AMPA
        g_ampa nS = 0 nS
        g_ampa' nS/ms = 0 nS/ms

        # Beta
        g_beta nS = 0 nS
        g_beta' nS/ms = 0 nS/ms

        # NMDA
        g_nmda nS = 0 nS
        g_nmda' nS/ms = 0 nS/ms
        g_ampa_nmda nS = 0 nS
        g_ampa_nmda' nS/ms = 0 nS/ms

    equations:
        inline V_bounded mV = min(V_m_s, V_max) # prevent exponential divergence
        inline V_boundedD mV = min(V_m_d, V_max)   #EPA

        # Add inlines to simplify the equation definition of V_m_s
        # Soma
        inline exp_arg real = (V_bounded - e_Na_Adex) / delta_T
        inline I_spike pA = g_L_s * delta_T * exp(exp_arg)

        g_exc'' = -2 * g_exc' / tau_syn_exc - g_exc / tau_syn_exc**2
        g_inh'' = -2 * g_inh' / tau_syn_inh - g_inh / tau_syn_inh**2

        inline I_syn_exc pA = g_exc * (V_bounded - E_exc)
        inline I_syn_inh pA = g_inh * (V_bounded - E_inh)
        recordable inline I_C pA = g_C_d * (V_m_s - V_m_d)

        V_m_s' = (-g_L_s * (V_bounded - e_L_s) + I_spike - I_syn_exc - I_syn_inh - g_w * w + I_e + I_stim - I_C) / C_m_s
        w' = (a * (V_bounded - e_L_s) - w) / tau_w

        # Distal
        g_excD'' = -2 * g_excD' / tau_syn_excD - g_excD / tau_syn_excD**2
        g_inhD'' = -2 * g_inhD' / tau_syn_inhD - g_inhD / tau_syn_inhD**2

        inline I_syn_excD pA = g_excD * (V_boundedD - E_excD)
        inline I_syn_inhD pA = g_inhD * (V_boundedD - E_inhD)
        recordable inline mh real = m_Ca * h_Ca
        recordable inline e_Ca mV = e_Ca_calc(k_Ca, R_Ca, T_Ca, c_Ca_o, c_Ca, F_Ca)
        recordable inline I_Ca pA = gbar_Ca * m_Ca * h_Ca * (e_Ca - V_m_d)
        recordable inline I_K pA = gbar_K_Ca * m_K * (e_K - V_m_d)
        recordable inline I_CD pA = g_C_d * (V_m_d - V_m_s)    # Coupling current

        # AMPA synapse - distal
        g_ampa'' = -g_ampa' / tau_d_ampa + (-g_ampa / tau_d_ampa - g_ampa') / tau_r_ampa
        inline I_AMPA_d pA = g_ampa * (e_AMPA - V_m_d)

        # beta synapse
        g_beta'' = -g_beta' / tau_d_beta + (-g_beta / tau_d_beta - g_beta') / tau_r_beta
        recordable inline I_BETA_d pA = g_beta * (e_L_beta - V_m_d)

        # NMDA
        g_ampa_nmda'' = -g_ampa_nmda' / tau_d_ampa + (-g_ampa_nmda / tau_d_ampa - g_ampa_nmda') / tau_r_ampa
        g_nmda'' = -g_nmda' / tau_d_nmda + (-g_nmda / tau_d_nmda - g_nmda') / tau_r_nmda
        inline I_AMPA_NMDA_d pA = g_ampa_nmda * (e_L_AMPA_NMDA_d - V_m_d) + nmda_ratio * \
                                  g_nmda * (e_L_AMPA_NMDA_d - V_m_d) / (1. + 0.3 * exp( -.1 * V_m_d ))
        V_m_d' = (-g_L_d * (V_boundedD - e_L_d) - I_syn_excD - I_syn_inhD + I_AMPA_d + I_BETA_d + I_AMPA_NMDA_d + I_Ca + I_K + I_eD + I_stimD - I_CD) / C_m_d
        m_Ca' = (m_inf_Ca(V_m_d) - m_Ca) / tau_m
        h_Ca' = (h_inf_Ca(V_m_d) - h_Ca) / tau_h
        c_Ca' = phi * I_Ca + (Ca_0 - c_Ca) / tau_decay_Ca
        m_K' = (m_inf_K(c_Ca) - m_K) / tau_m_K_Ca

        refr_t' = -1e3 * ms/s    # refractoriness is implemented as an ODE, representing a timer counting back down to zero. XXX: TODO: This should simply read ``refr_t' = -1 / s`` (see https://github.com/nest/nestml/issues/984)

    parameters:
        # membrane parameters

        C_m_s pF = 246.7882968598874 pF         # Membrane Capacitance
        C_m_d pF = 23.67372778891213 pF
        t_ref ms = 0 ms          # Duration of refractory period
        d_BAP ms = 0.1195980511869619 ms           # Back propagation delay
        w_BAP mV = 27.995561755479308 mV
        V_reset mV = -61.73952230767877 mV     # Reset Potential
        g_L_s nS = 5.0 nS          # Leak Conductance
        g_L_d nS = 3.377855016658499 nS
        g_C_d nS = 19.777320239615996 nS
        g_w nS = 1.1156385639067352 nS
        gbar_Ca nS = 21.045506331690845 nS
        gbar_K_Ca nS = 13.199867205029523 nS
        e_L_s mV = -69.24596493128396 mV         # Leak reversal Potential (aka resting potential)
        e_L_d mV = -55.000000000000014 mV
        # e_Ca mV = 132 mV
        e_K mV = -90 mV

        # spike adaptation parameters

        a real = 0.               # Subthreshold adaptation
        b mV = 40. mV            # Spike-triggered adaptation
        delta_T mV = 2.0 mV       # Slope factor
        tau_w ms = 500.0 ms       # Adaptation time constant
        e_Na_Adex mV = -50. mV        # Spike initiation threshold
        V_th mV = -40. mV          # Spike detection threshold
        V_th_d mV = 0 mV          # Spike detection threshold
        V_max mV = 50 mV         # Bounding potential

        # synaptic parameters

        E_exc mV = 0 mV            # Excitatory reversal Potential
        tau_syn_exc ms = 0.2 ms    # Synaptic Time Constant Excitatory Synapse
        E_inh mV = -85.0 mV        # Inhibitory reversal Potential
        tau_syn_inh ms = 2.0 ms    # Synaptic Time Constant for Inhibitory Synapse

        # Distal
        # synaptic parameters

        E_excD mV = 0 mV            # Excitatory reversal Potential
        tau_syn_excD ms = 0.2 ms    # Synaptic Time Constant Excitatory Synapse
        E_inhD mV = -85.0 mV        # Inhibitory reversal Potential
        tau_syn_inhD ms = 2.0 ms    # Synaptic Time Constant for Inhibitory Synapse

        phi pA**-1 = 3.92830985228413e-08 pA**-1
        Ca_th mmol = 0.00043 mmol   # Calcium concentration threshold
        Ca_0 mmol = 0.0001 mmol  # Calcium concentration baseline
        tau_decay_Ca ms = 103.57233790866408 ms

        m_slope real = 0.5
        m_half mV = -9 mV
        tau_m ms = 15 ms

        h_slope real = -0.5
        h_half mV = -21 mV
        tau_h ms = 80 ms

        exp_K_Ca real = 4.8
        tau_m_K_Ca ms = 1.0 ms

        # to compute the Ca current reversal potential
        k_Ca mV = 1000 mV
        R_Ca real = 8.31441
        T_Ca real = 309.15
        F_Ca real = 96489
        c_Ca_o mmol = 2. mmol  # Calcium concentration outside the neuron

        # Constant external input current
        I_e pA = 0 pA
        I_eD pA = 0 pA

        # AMPA synapse
        tau_r_ampa ms = 0.2 ms
        tau_d_ampa ms = 3.0 ms
        e_AMPA mV = 0 mV

        E_Na mV = 55 mV

        # Beta synapse
        tau_d_beta ms = 5 ms
        tau_r_beta ms = 2 ms
        e_L_beta mV = 90 mV

        # AMPA-NMDA synapse
        tau_r_nmda ms = 0.2 ms
        tau_d_nmda ms = 43 ms
        e_L_AMPA_NMDA_d mV = 0 mV
        nmda_ratio real = 2.0

    internals:
        tp_ampa real = (tau_r_ampa * tau_d_ampa) / (tau_d_ampa - tau_r_ampa) * ln( tau_d_ampa / tau_r_ampa )
        g_norm_ampa real =  1. / ( -exp( -tp_ampa / tau_r_ampa ) + exp( -tp_ampa / tau_d_ampa ) )

        tp_nmda real = (tau_r_nmda * tau_d_nmda) / (tau_d_nmda - tau_r_nmda) * ln( tau_d_nmda / tau_r_nmda )
        g_norm_nmda real =  1. / ( -exp( -tp_nmda / tau_r_nmda ) + exp( -tp_nmda / tau_d_nmda ) )

        ## BETA receptor
        tp_max_beta real = tau_d_beta * ( tau_r_beta * tau_d_beta / ( tau_r_beta + tau_d_beta ) ) / ( ( tau_r_beta * tau_d_beta / ( tau_r_beta + tau_d_beta ) ) - tau_d_beta) * ln( ( tau_r_beta * tau_d_beta / ( tau_r_beta + tau_d_beta ) ) / tau_d_beta )
        g_norm_beta real =  exp( -tp_max_beta / tau_d_beta ) - exp( -tp_max_beta / ( tau_r_beta * tau_d_beta / ( tau_r_beta + tau_d_beta ) ) )

    input:
        exc_spikes_soma <- spike
        inh_spikes_soma <- spike
        I_stim pA <- continuous
        # Distal
        exc_spikes_distal <- spike
        inh_spikes_distal <- spike
        I_stimD pA <- continuous

        spikes_ampa_d <- spike
        spikes_beta_d <- spike
        spikes_ampa_nmda_d <- spike

    output:
        spike

    onReceive(exc_spikes_soma):
        g_exc' += exc_spikes_soma * (e / tau_syn_exc) * nS * s

    onReceive(inh_spikes_soma):
        g_inh' += inh_spikes_soma * (e / tau_syn_inh) * nS * s

    onReceive(exc_spikes_distal):
        g_excD' += exc_spikes_distal * (e / tau_syn_excD) * nS * s

    onReceive(inh_spikes_distal):
        g_inhD' += inh_spikes_distal * (e / tau_syn_inhD) * nS * s

    onReceive(spikes_ampa_d):
        g_ampa' += spikes_ampa_d * g_norm_ampa * (1 / tau_r_ampa - 1 / tau_d_ampa) * nS * s

    onReceive(spikes_beta_d):
        g_beta' += spikes_beta_d * g_norm_beta * (1 / tau_r_beta - 1 / tau_d_beta) * nS * s

    onReceive(spikes_ampa_nmda_d):
        g_ampa_nmda' += spikes_ampa_nmda_d * g_norm_ampa * (1 / tau_r_ampa - 1 / tau_d_ampa) * nS * s
        g_nmda' += spikes_ampa_nmda_d * g_norm_nmda * (1 / tau_r_nmda - 1 / tau_d_nmda) * nS * s

    update:
        if refr_t > 0 ms:
            # neuron is absolute refractory, do not evolve V_m_s
            integrate_odes(w, V_m_d, c_Ca, m_Ca, h_Ca, m_K, refr_t, g_exc, g_excD, g_inh, g_inhD, g_ampa, g_beta, g_ampa_nmda, g_nmda)
        else:
            # neuron not refractory
            #println("V_m_s: {V_m_s}, V_m_d: {V_m_d}, I_C: {I_C}, I_CD: {I_CD}, m_Ca: {m_Ca}, h_Ca: {h_Ca}, mh: {mh}, c_Ca: {c_Ca}, I_Ca: {I_Ca}")
            integrate_odes(w, V_m_s, V_m_d, c_Ca, m_Ca, h_Ca, m_K, g_exc, g_excD, g_inh, g_inhD, g_ampa, g_beta, g_ampa_nmda, g_nmda)
        #println("V_m_s: {V_m_s}, w: {w}, I_stim: {I_stim}")

    onCondition(refr_t <= 0 ms and V_m_s >= V_th):
        # threshold crossing
        refr_t = t_ref    # start of the refractory period
        bap_t = d_BAP      # start the backprop period
        # bap_active = true
        V_m_s = V_reset
        w += b
        emit_spike()

    function m_inf_Ca(v mV) real:
        # m_Ca_ = 1. / ( 1. + std::exp( m_slope * ( v_rest_ - m_half ) ) );
        m_inf real = 0
        m_inf = 1 / (1 + exp(m_slope * (v - m_half)))
        return m_inf

    function h_inf_Ca(v mV) real:
        # h_Ca_ = 1. / ( 1. + std::exp( h_slope * ( v_rest_ - h_half ) ) );
        h_inf real = 0
        h_inf = 1 / (1 + exp(h_slope * (v - h_half)))
        return h_inf

    function m_inf_K(Ca real) real:
        # m_K_Ca_ = 1. / ( 1 + std::pow(Ca_th_/Ca_conc_,exp_K_Ca_));
        m_inf real = 0
        m_inf = 1 / (1 + pow((Ca_th / Ca), exp_K_Ca))
        return m_inf

    function e_Ca_calc(k_Ca mV, R_Ca real, T_Ca real, c_Ca_o mmol, c_Ca mmol, F_Ca real) mV:
        e_Ca_rev mV = 0. mV
        e_Ca_rev = k_Ca * R_Ca * T_Ca * ln( c_Ca_o / c_Ca ) / ( 2. * F_Ca )
        return e_Ca_rev